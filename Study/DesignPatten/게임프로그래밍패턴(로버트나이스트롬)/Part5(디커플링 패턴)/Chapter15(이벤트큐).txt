Chapter15(이벤트큐)
15.1 의도
- 메세지와 이벤트를 보내는 시점과 처리하는 시점을 디커플링한다.

15.2 동기
- GUI 버튼 클릭시 오디오 시스템에 접근하여 소리가 난다고 해보자 버튼 이벤트 발생시 오디오에 접근하여 오디오를 플레이하면 가끔 뚝뚝 끊
  기는 경우가 생긴다 오디오 엔진이 요청을 완전히 처리할 때까지 호출자를 블록하기 때문이다. 또한 여러 오디오를 모아서 한번에 처리하지 
  못한다 동기적이다 또한 몬스터로 부터 타격을 받을대바다 소리를 낸다고 한다면 한프레임이 두명의 몬스터로부터 타격을 받았다고 해보자 
  사운드가 겹쳐 더 크게들리거나 거슬리게 들린다.
  이 모든게 요청하면 바로 오디오를 틀려고하는 즉시성이 문제다.
  이를 해결하기 위해 요청을 입력부분과 처리부분을 분리해야한다.

15.3 패턴
- 큐는 요청을 순서대로 저장하고 요청하는 곳에서는 리턴시킨다 처리하는 부분에서는 큐에 들어있는 요청을 나중에 처리한다 이렇게 되면
  코드뿐만 아니라 시간까지도 디커플링된다.

15.4 언제 쓸 것인가? 
- 요청자와 처리자를 분리하는 목적이라면 더 복잡하고 단순한 명령패턴이나 관찰자패턴을 사용하면된다 하지만 시점을 분리하고 싶다면 
  큐가 필요하다. 한쪽에서는 밀어넣고 한쪽에서는 가져와야된다면 그 사이에 버퍼가 필요하다 그게 큐이다 

15.5 주의사항
- 다른 패턴에 비해 복잡하고 게임 전반적인 구조에 영향을 미칠수 있기 때문에 꼭 필요한지 생각해보고 결정해야한다.
- 중앙 이벤트 큐는 전역 변수와 같다 어디서나 접근할 수 있다보니 온갖 미묘한 상호의존성에 문제가 생길수있다 그래서 전역변수 사용에는 
  주의가 필요하다.
- 월드 상태는 언제든지 바뀔수 있다?.
- 피드백 루프에 빠질수 있다. 이벤트를 처리하는 부분에서는 이벤트를 또 만들지 말자.

15.6 예제코드
- 생략.

15.7 디자인 결정
- 큐에 무엇을 넣을것인가? 인벤트, 메세지
- 누가 큐를 읽는가? 싱글큐, 브로드큐, 작업큐
- 누가 큐에 값을 넣는가? 넣는측이 하나, 여러개
- 큐에 들어간 객체의 생명주기는? 소유권전달, 소유권공유, 큐가 소유권을 가진다