Chapter14(컴포넌트)
14.1 의도
- 한 객체가 여러분야를 커플링 없이 다룰 수 있게 한다.

14.2 동기 
- 캐릭터 객체에 입력부터 시작해서 물리, 사운드 필요한 기능들을 한 클래스에 넣어 사용하게되면 코드가 길어질 뿐 아니라 가독성도 떨어지고
  유지보수도 힘들다 더 큰 문제는 커플링되어 한 부분을 이해하려면 커플링된 부분까지 봐야되므로 힘들어진다.
- 서로 몰라되는 기능들고 분리하고 해당 기능의 인스턴스를 갖게하자.(고르디우스의 매듭 끊기) 
- 이렇게 사용하면 코드 재사용이 용이 해지고 서로 커플링 되지 않는다.
- 데코레이션 : 상호작용을 할수 없는 객체. 먼지나 덤불등
  프랍 : 볼수있으면서 상호작용이 가능한 객체. 상자, 나무, 바위 등
  존 : 프랍과 반대로 볼수는 없지만 상호작용을 가능한 객체. 물리, 충돌 등
- 기능을 컴포넌트화 하여 물리 및 그래픽 렌더링으로 나누어 클래스를 만들고 해당 컴포넌트가 필요한 객체에만 가져다 붙이면 된다
  예를 들어 데코레이션은 렌더링 컴포넌트만 있으면 되며 프랍은 물리, 렌더링이 모두 필요하니 둘다 붙이면 되고 존은 물리만 있으면 된다
  컴포넌트는 기본적으로 객체를 위한 플래그 앤 플레이라고 볼수 있다.
  개체 소켓에 재사용이 가능한 여러 컴포넌트 객체를 꽂아 넣음으로써 복잡한 기능의 풍부한 개체를 만들수 있다.

14.3 패턴 
- ? 

14.4 언제 쓸 것인가?
- 한 클래스가 여러 기능을 가지고 있어서 디커플링하고 싶은경우.
- 한 크래스가 너무 클때.
- 여러 다른 기능을 공유하는 개체를 만들고 싶은경우.

14.5 주의사항
- 한 클래스의 코드를 모아놓은것 보다 더 복잡해 질 수 있다 한 무리의 개체를 생성하고 알맞게 묶어줘야 하나의 개념적인 객체를 만들수 있기 
  때문이다.
- 무슨 일이든 컨테이트 객체를 통해서 얻어와야 하기때문에 포인터를 따라가다 보면 성능에 떨어질수있다.

14.6 예제코드 
- 코드생략

14.7 디자인 결정
- 어떤 컴포넌트 집합이 필요한가? 게임 코드가 더 크고 복잡할수록 세분화 해야된다.
- 객체가 컴포넌트를 어떻게 생성할 것인가? 알아서 생성하면 실수가 줄어드는 대신에 객체변경이 힘들고 외부로 부터 생성하면 훨씬 유연해지며
  객체를 구체 컴포넌트 자료형으로부터 디커플링 할 수 있다.
- 컴포넌트 끼리 어떻게 소통할 것인가? 
  *객체의 상태를 변경하는 방식 : 디커플링된다, 컨포넌트끼리 필요한 정보를 객체가 모두 들고있어야된다, 실행 순서에 의존하게된다.
   모든 객체에서 당연히 있을 거라고 생각하는 정보에 사용하면 좋다.
  *컨포넌트가 서로 참조하는 방식 : 간단하고 빠르다, 두 컴포넌트가 강하게 디커플링된다.
   서로 쌍이 되는 입력과AI 또는 물리와충돌 부분에 사용하면 좋다.
  *메세지를 전달하는 방식 : 상위 컨포넌트 클래스를 두고 receive 가상 메서드를 만들어 구현하게 하고 컴포넌트 메세지를 관리하는 중재자를 
   만들어 모든 컴포넌트에게 메세지를 전달하는 방식. 중재라를 통해서 전달하므로 메세지와 커플링된다.
   메세지를 호출하고 나서 서로 신경쓰지 않아도 되는 사소한 통신에 사용하기 좋다. 예를 들어 물리 충돌후 오디오 컴포넌트가 이를 받아서 소리
   를 낸다던지.