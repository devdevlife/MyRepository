Chapter16(서비스중개자)
16.1 의도
- 서비스를 구현한 구체클래스는 숨긴채로 어디서나 서비스를 이용할수 있게한다?.

16.2 동기
- 메모리할당이나 로그, 난수 생성등 일종의 서비스라고 볼수있다. 이런시스템은 게임 전체에서 사용가능해야한다.
  사운드를 플레이하는 구체클래스가 있다고 해보자 사운드 출력 메서드를 실행하려면 싱글턴이나 정적클래스 메커니즘까지 직접 참조해야된다
  이는 마치 우편물을 받기위해 수많은 이방인들에게 내 집 주소를 알려주는 것과 같다. 개인정보가 노출되기도 하지만 주소가 바뀌면 일일이 다
  변경된 주소로 수정해 주어야 한다 전화국을 통해서 주소지를 변경하고 관리한다면 업데이트 받아 사용하면 된다 이렇게 찾는 방법을 한곳에서
  편리하게 관리 할 수 있다 이게 서비스 중개자 패턴의 핵심이다.

16.3 패턴
- 서비스는 여러 기능들을 추상 인터페이스로 정의하고 서비스제공자는 이를 받아 서비스를 구현한다. 이와 별개로 서비스중개자는 서비스 제공자
  의 실제 자료형과 등록 과정을 숨긴채 적절한 서비스제공자에 접근할 수 있다.

16.4 언제 쓸 것인가?
- 무엇이든 프로그램 어디서나 접근할수 있다면 문제가 생기기 쉽다 싱글턴 패턴의 문제점 이기도 했다 접근해야 할 객체가 있다면 생성자의 
  인수로 넘겨서 사용 할수있다면 그렇게 사용하자 간단하면서도 명확하다 하지만 이런 방법이 불필요하거나 코드를 읽기 어렵게 하기도 한다
  이 패턴은 더 유연하고 설정하기 좋은 싱글턴 패턴이다. 잘만 사용하면 런타임 비용을 거의 들지 않고도 코드를 유연하게 만들 수 있다.

16.5 주의사항
- 두 코드가 커플링 되는 의존성을 런타임까지 미루기가 어렵다?
- 유연성은 얻을 수 있지만 코드만 봐서는 어떤 의존성을 사용하지는 알기 어렵다는 비용이 발생한다.
- 서비스가 실제로 등로되어 있어야 한다 없다면 이에 대한 대비를 해놓아야한다.
- 서비스는 누가 자신을 가져도 놓는지 모른다 어떤 환경에서도 문제없이 동작해야한다 어떤 클래스가 특정 상황에서만 돌아가야 한다면 사용하지
  말자.

16.6 예제코드
- 생략.

16.7 디자인 결정
- 서비스를 어떻게 등록할 것인가?
  *외부 코드에서 등록(의존성 주입) : 빠르고간단, 서비스 제공자를 어떻게 만들지 제어할 수 있다, 런타임중에 서비스 교체가능, 서비스 중개자가 
  외부 코드에 의존해야 된다는 단점이 있음.
  *컴파일 할때 바인딩(전처리기 매크로) : 빠르다, 서비스는 항상 사용가능하다, 서비스를 쉽게 변경할 수 없다는 단점이 있음.
  *런타임에 설정값 읽기 : 다시 컴파일 하지 않고도 서비스교체가 가능하다 하지만 재시작해야됨, 복잡하다, 시간이 오래걸린다, 프로그래머가 
  아니여도 변경이 가능하다, 등록과정을 코드에서 빼냈기 때문에 여러 설정을 동시에 지원할 수 있다.

- 서비스를 못 찾으면 어떻게 할 것인가?
  *사용자가 알아서 처리한다.
  *게임을 멈춘다 : 서비스를 찾지 못했음을 중개자에게 확실히 알려줘야된다.
  *널 서비스를 반환한다 : 대규모 프로젝트에 적함. 서비스 기능 하나가 없더라도 게임은 진행되어야 한다.

- 서비스 범위는 어떻게 잡아야 하나?
  *전역에서 접근 가능한 경우
  *특정 클래스에 제한된 경우