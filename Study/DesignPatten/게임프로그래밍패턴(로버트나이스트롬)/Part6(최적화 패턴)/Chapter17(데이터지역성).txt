Chapter17(데이터지역성)
17.1 의도
- CPU캐시를 적극 활용할 수 있도록 데이터를 배치하고 메모리 접근 속도를 향상시킨다.

17.2 동기
- CPU 연산속도는 날로 좋아지지만 데이터 이동 속도는 발전 하지 못하는 실정이다 환경에 따라 차이가 있을수 있지만 캐시라인을 최적으로 
  사용하할 때와 최악으로 사용할때의 속도차이는 많게는 무려 50배 정도 난다.
- 칩이 어떤 데이터를 읽을 때마다 캐시라인을 같이 읽어온다 캐시라인에 있는값을 많이 사용할수록 더 빠르게 만들 수 있다.
- 자료구조를 잘 만들어서 처리하려는 값이 메모리 내에서 서로 가까이 붙어 있도록 하는것이 우리의 목표이다

17.3 패턴
- 데이터 지역성이 높을수록 즉 데이터를 처리하는 순서대로 연속된 메모리에 둘수록 성능을 향샹시킬수있다.

17.4 언제 쓸 것인가?
- 성능 문제가 있을때 사용하면 되지만 잘 사용되지 않는 코드에 불필요하게 시간낭비 하지말자.
- 성능 문제가 캐시미스인지 확인하라 캐시미스일때만 사용하고 아니면 불필요하다(캐시 미스를 확인하는 프로파일러가 이미 많이 있다).
- 캐시 미스를 확인 한 후에 성능에 영향이 미친다면 적용해도 되겠지만 개발 기간 내내 자료구조를 캐시하기 좋게 만들려고 노력할 필요가있다.

17.5 주의사항
- 지역성패턴을 사용하려면 추상화를 일부 희생해야한다 상속및 인터페이스로 부터 얻을수 있는 이득을 포기해야 한다.
  가상함수호출은 vtable 포인터를 추적하기위해 캐시미스가 생길수 있다.

17.6 예제코드
- 생략.

17.7 디자인결정
- 다형성은 어떻게 할것인가?
  *사용하지 않는다 : 안전하고쉽다, 더 빠르다, 유연하지 않다(추상및 상속을 사용할수 없음).
  *종류별로 다른 배열에 넣는다 : 객체를 빈틈없이 담을 수 있다, 저적 디스패치를 할수 있다, 여러 컬렉션을 관리해야한다, 모든 자료형을 알아야 
  한다
  *하나의 컬렉션에 포인터를 모아놓기 : 유연하다, 캐쉬 친화적이지 않다(캐시 미스 발생).
- 게임 개체를 어떻게 정의할 것인가? 
  *게임 개체 클래스가 컴포넌트를 포인터로 들고있을 때 : 컴포넌트를 배열에 저장할 수 있다, 개체로 부터 컴포넌트를 쉽게 얻을수 있다, 컴포넌트를
  메모리로 옮기기 쉽지 않다.(활성화 된 컴포넌트 앞 정렬, 컴포넌트 복사가 이루어짐)
  *게임 개체 클래스가 컴포넌트를 아이디로 가지고 있을 때 : 더 복잡하다, 더 느리다, 컴포넌트 관리자에 접근해야된다.
  *게임 개체가 단순히 아이디 일 때 : 개체가 단순해진다(개체의 아이디만 가지고 있으면 데이터 공유도된다), 개체가 비어있다?, 개체 생명주기를 
  관리 하지 않아도 된다, 특정 개체의 컴포넌트를 찾는데 느릴 수 있다,


