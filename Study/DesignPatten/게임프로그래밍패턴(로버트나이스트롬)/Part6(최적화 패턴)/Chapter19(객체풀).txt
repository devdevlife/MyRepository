Chapter19(객체풀)
19.1 의도
- 객체를 매번 할당, 해제 하지 않고 고정 풀에 들어있는 객체를 재사용 함으로서 메모리 사용 성능을 개선한다.

19.2 동기
- 마법을 사용하면 수백개의 파티클이 생성된다고 생각하자 빠르게 파티클을 생성해야 되며 메모리 단편화가 발생할수 있다.
  이 두가지를 해결 할 수 있는것이 객체 풀 패턴이다.

19.3 패턴
- 재사용가능한 객체들을 모아놓은 객체 풀 클래스를 정의하고 사용중인지를 확인할수 있는 방법을 제공해 주며 재사용 가능한 객체들을 배열에
  할당하여 미사용으로 초기화 한다. 객체가 필요할 때마다 사용으로 변경 후 내어주면 되고 다 사용된 객체는 미사용으로 변경후 반환해주면
  된다. 

19.4 언제 쓸 것인가?
- 객체들의 크기가 비슷하다.
- 메모리에 할당및 해제가 번번이 일어날때.
- 객체를 힙에 생성하기 느리거나 메모리 단편화가 우려될때.
- 데이터베이스 접근이나 네트워크 연결과 같은 접근 비용이 비싸면서 재사용 가능한 객체를 캡슐화하여 가지고 있을때.

19.5 주의사항
- 객체풀을 할당해 놓고 사용하지 않는다면 메모리 낭비이다.
- 객체풀은 객체를 스스로 초기화 해주지 않는다.
- 객체를 위한 메모리 크기는 고정되어있다.(여러 타입을 같이 사용한다면 가장 큰 사이즈에 맞춰야하며 차이가 많이 날 경우 큰것, 작은것 
  분리 하여 사용 하자)
- 사용 중이지 않은 객체도 남아있다.(GC가 있더라도 사용하지 않을경우 해제해 주지 않는다 참조가 하나라도 없어야 된다)
- 한번에 사용할 객체의 수가 정해져 있다.(상황에 맞게 풀의 사이즈를 조정할 수 있어야 한다)

19.6 예제코드
- 생략.
- 객체 안에 사용하지 않을 경우 다음 풀의 위치를 주소로 가지고 있자 그러면 객체풀은 firstAvailable 의 위치만 가지고 있으면 된다 
  필요할때는 처음객체를 주면되고 다시 다음 객체의 주소를 firstAvailable 저장해 주면된다. 반환된 객체는 다음주소에 firstAvailable 를 저장
  하고 자신의 주소를 다시 firstAvailable 등록. 

19.7 디자인 결정
- 풀이 객체와 커플링 되는가?
  *커플링된다 : 간단하게 구현할 수 있다, 객체가 풀을 통해서만 생성가능하게 할수있다, 사용중 플래그가 필요없다,
  *커플링되지 않는다 : 어떤 객체든 넣을수 있다, 사용중 상태를 외부에서 관리해야한다??, 
- 재사용되는 객체를 초기화할 때 어떤 점을 주의해야 하는가?
  *객체를 풀 안에서 초기화 한다 : 객체를 캡슐화할 수 있다, 풀클래스 초기화 방법이 객체와 결합된다.
  *객체를 풀 밖에서 초기화 한다 : 풀의 인터페이스가 단순해진다, 외부코드에서 객체 초기화 실패시 처리도 해주어야한다,