Chapter7(상택)
7.1 추억의 게임 만들기
- 입력에 맞춰서 캐릭터를 컨트롤 하는 코드를 명령패턴을 써서 만들어보자 만들다보다 여러가지 제약사항들이 생기고 생길때마다 예외처를 
  해줘야 된다 제약사항이 늘어날때마다 코드가 엉망이 되어간다 이럴때 사용하는게 상태패턴이다.

7.2 FiniteStateMachine(FSM) 이 우리를 구원하리라
- 펜과 종이를 들고 플로차트를 그려보자 동작을 네모칸에 적고 어떤 버튼을 눌렀을때 상태가 바뀐다면 이전상태에서 다음상태로 화살표를 
  그려 눌렀던 버튼을 적는다 이게 FSM 플로우차트다.
- 요점은 이렇다.
  가질수 있는 상태가 한정된다
  한번에 한가지 상태만 될수있다
  입력과 이벤트가 기계에 전달된다
  각 상태에서 입력에따라 다음 상태로 바뀌는 전이(transition)가있다 순수하게 형식만 놓고 본다면 상태, 입력, 전이가 전부이다.

7.3 열거형과 다중 선택문
- 캐릭터의 상태가 중복되지 않기때문에 열거형으로 사용하고 다중 선택문으로 사용하여 상태에따라 분기해보자.
  업데이트 해야할 상태변수가 하나로 줄었으며 하나의 상태를 관리하는 코드는 깔끔하게 한곳에 모였다.

7.4 상태 패턴
- 다중 선택문에 있던 상태들을 하나의 인터페이스의 가상 메서드로 만든다.
  각 상태클래스를 만들어 인터페이스 구현하고 상태값을 상위 클래스 포인터로 관리하는것 이게 상태패턴의 전부이다.

7.5 상태 객체는 어디에 둬야 할까?
- 각각 상태별로 정적 인스턴스는 하나씩만 가지고 있으면 된다. 둘때가 마당치 않다면 인터페이스 대신 상위 클래스로 만들어서 들고 있어도된다.
- 상태 하나가 에너지를 일정시간 모아서 폭팔시키는 상태기능이 있고 캐릭터마다 시간이 다르다면 정적으로 사용하기가 힘들다 이전 상태를 반환
  하고 새로운 상태를 저장하도록 바꿔보자. 이렇게 사용하면 매번 상태객체를 할당하기위해 메모리와 cpu를 낭비해야되니 다른방법을 찾아보자.

7.6 입장과 퇴장
- 상태패턴의 목표는 같은 상태에 대한 모든 동작과 데이터를 하나의 클래스로 캡슐화하여 관리하는것이다.
- 상태가 바뀌면 바뀐상태의 입장과 퇴장 메서드를 만들어 관리하는것도 좋다.

7.7 단점은?
- 상태기계는 인공지능같이 더 복잡한 곳에 사용하게 되면 한계에 부딪히게 된다 해결 방법을 알아보자.

7.8 병행 상태 기계
- FPS게임처럼 이동중 무기를 써야하는경우 무엇을 하는가에 대한 상태기계는 그대로 두고 무엇을 들고있는가에 대한 상태를 추가하고 분리
  사용한다 이렇게하면 각각 독립적으로 상태에 대한 변경이 가능하다 단 두 상태기계가 연관이 없다면 사용해도 좋다
  연관이 있어서 서로 상호작용해야한다하면 상호작용을 체크해야하는 지저분한 코드가 만들어질수 있다.

7.9 계층형 상태 기계
- 상속으로 여러상태가 코드를 공유할수도 있다 점프와 엎드리기 땅 위의 있는 상태 클래스를 정의해 처리하고 서기, 달리기, 걷기, 미끄러지기
  는 땅 위에 있는 상태를 상속받아 고유 동작을 추가하면된다. 이런 구조를 계층형 상태 기계라고 한다.

7.10 푸시다운 오토마타
- FSM은 총을 쏜후 이전 상태로 돌아갈수 없다 직전상태를 따로 저장하지 않기 때문이다 이럴때 사용하는 방법이 푸시다운 오토마타이다.
  FSM은 한개의 포인터로 상태값을 관리했다면 오토마타는 스택으로 상태를 관리한다 
- 의문점: 달려가면서 총을 쏘다가 달려가기 버턴을 놓으면 어떻게 되는가.. 계층형 상태에서 푸시다운 오토마타를 적용하나?.. 

7.11 얼마나 유용한가?
- FSM 몇가지 확장팩들이 있지만 한계가 그래도 있음.. 요즘 AI는 행동트리(behaviorTree)나 계획시스템(planningSystem)을 많이 사용한다 
  관심있다면 다른책들을 찾아보자.
- 그렇다고 FSM나 푸시다운오토마타다 쓸모없다는 것은 아님 다음과 같은 경우에는 사용하면 좋다
  내부 상태에 따라 객체의 동작이 바뀔때
  상태가 많지 않은 선택지로 분명하게 구분될때
  객체가 입력이나 이벤트에 따라 반응할때


