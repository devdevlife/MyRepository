Chapter4(관찰자) / 관찰자패턴
4.1 업적달성
- 업적은 여러 플레이 요소에서 사용된다 커플링 되지 않고 사용하려면 관찰자 패턴을 사용하면 된다.
- 해당 패턴을 적용하면 누가 받든 상관없이 알림을 보내면 된다.

4.2 작동원리
- 통보받을수 있는 시스템이 정의된 인터페이스를 만들어 각 종 옵저버를 실체화 시켜 관리해줄 매니저에 등록한다.
  그러면 메니져는 해당 이벤트가 들어오면 해당 옵저버를 찾아서 통보해주면 된다.
- 매니저는 오저버 등록과 삭제 기능을 재공해 주면되고 필요한 오저버는 메니저에 접근하여 등록하면 됨.
- 대상은 관찰자와 상호작용을 하지만 서로 커플링되어 있지 않다.

4.3 너무 느려
- 성능에 민감한 코드가 아니라면 이정도는 문제가 되지 않으며 인터페이스를 통해 동기적으로 메서드를 간접 호출할 뿐 메세지용 객체를 
  할당하지도 않고 큐잉도 하지 않는다.
- 주의해야될 점은 관찰자 패턴이 동기적이라는것 모든 관찰자가 알림 메서드를 반환하기 전까지는 다음으로 진행이 되지 않는다 관찰자 중 
  하나라도 느리면 블록될수있다.
- 관찰자를 멀티쓰레드와 락을 함께 사용한다면 주의해야한다 어떤 관찰자가 락을 물고있다면 게임이 교착상태에 빠질수 있다 이런경우에는 
  이벤트 큐를 활용해 비동기적으로 상호작용하는게 더 좋다.

4.4 동적 할당을 너무 많이 해
- 관찰자 인터페이스에 다음 관찰자를 가리키는 주소를 저장하는 변수를 추가하여 등록해주는 기능을 넣어주면 별도로 동적 할당할 필요가없다.
- 관찰자를 노드화 하여 객체 풀 관리를 하면 동적 메모리 할당 없이 재사용할 수 있다.

4.5 남은 문제점들
- 디자인 패턴의 평판이 나빠진건 사람들이 좋은 패턴을 상황에 맞지 않게 사용하기 떄문이다.
- 대상 삭제시 관찰자들에게 사망을 통보 한 후 제거하면 된다.
- 관찰자 상위 클래스에서 등록 취소 메소드를 구현한후 사용하면된다 단 대상을 관리해야하기 때문에 서로 상호참조가 생겨 복잡성이 늘어난다는
  단점이 있다.
- 가비지 컬렉터가 자동으로 메모리 관리를 하지만 UI를 관찰자로 등록한 후 사용하지 않을때 제거 하지 않는다면 가비지는 계속 쌓이게 된다. 이는 
  알림시스템에서 굉장히 자주 일어나는 문제다 보니 사라진 리스너 문제라는 고유한 이름이 붙었을 정도다 등록 취소에 신경써야할 부분이다.
- 디컬플링의 장점은 서로 간접적으로 상호작용을 하기때문이다 하지만 문제가 생기면 상호작용 흐름을 파악하기가 어렵다 명시적으로 커플링 되어
  있다면 어떤 메소드가 호출되는지만 보면 된다. 디커플링은 런타임에서 확인할 수밖에 없다. 이렇게 상호간에 참조해야할 일이 생긴다면 그냥 
  관찰자 대신 명시적으로 연결하는게 더 낫다.

4.6 오늘날의 관찰자
- 인터페이스를 상속받는 인스턴스보다 멤버 함수 포인터를 관찰자로 등록하여 사용한다. c#에서 event가 있어서 delegate 관찰자를 등록할수 있다.

4.7 미래의 관찰자
- 관찰자패턴 사용의 공통점 : 어떤 상태가 변했다는 알림을 받는다, 이를 반영해 UI상태 일부를 바꾼다.
- 요세 나오는 어플리케이션 프레임워크에는 데이터바인딩을 지원한다 하지만 너무 느리고 복잡하다 그래서 게임에서 성능에 덜 민감한 UI같은 
  부분에 데이터 바인딩이 대세가 될것이다. 관찰자 패턴도 계속해서 사용될것이다 단순하고 잘 작동하기 때문이다.
