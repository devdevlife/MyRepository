Chapter4(관찰자) / 관찰자패턴
4.1 업적달성
- 업적은 여러 플레이 요소에서 사용된다 커플링 되지 않고 사용하려면 관찰자 패턴을 사용하면 된다.
- 해당 패턴을 적용하면 누가 받든 상관없이 알림을 보내면 된다.

4.2 작동원리
- 통보받을수 있는 시스템이 정의된 인터페이스를 만들어 각 종 옵저버를 실체화 시켜 관리해줄 매니저에 등록한다.
  그러면 메니져는 해당 이벤트가 들어오면 해당 옵저버를 찾아서 통보해주면 된다.
- 매니저는 오저버 등록과 삭제 기능을 재공해 주면되고 필요한 오저버는 메니저에 접근하여 등록하면 됨.
- 대상은 관찰자와 상호작용을 하지만 서로 커플링되어 있지 않다.

4.3 너무 느려
- 성능에 민감한 코드가 아니라면 이정도는 문제가 되지 않으며 인터페이스를 통해 동기적으로 메서드를 간접 호출할 뿐 메세지용 객체를 
  할당하지도 않고 큐잉도 하지 않는다.
- 주의해야될 점은 관찰자 패턴이 동기적이라는것 모든 관찰자가 알림 메서드를 반환하기 전까지는 다음으로 진행이 되지 않는다 관찰자 중 
  하나라도 느리면 블록될수있다.
- 관찰자를 멀티쓰레드와 락을 함께 사용한다면 주의해야한다 어떤 관찰자가 락을 물고있다면 게임이 교착상태에 빠질수 있다 이런경우에는 
  이벤트 큐를 활용해 비동기적으로 상호작용하는게 더 좋다.

4.4 동적 할당을 너무 많이 해
- 관찰자 인터페이스에 다음 관찰자를 가리키는 주소를 저장하는 변수를 추가하여 등록해주는 기능을 넣어주면 별도로 동적 할당할 필요가없다.
- 관찰자를 노드화 하여 객체 풀 관리를 하면 동적 메모리 할당 없이 재사용할 수 있다.
